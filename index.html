<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Carlos Virgílio Beltrão Lessa" />


<title>TalkingData AdTracking - Desafio de detecção de fraude</title>

<script src="Projeto01_files/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="Projeto01_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="Projeto01_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="Projeto01_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="Projeto01_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="Projeto01_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="Projeto01_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="Projeto01_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="Projeto01_files/navigation-1.1/tabsets.js"></script>
<link href="Projeto01_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="Projeto01_files/highlightjs-9.12.0/highlight.js"></script>
<script src="Projeto01_files/kePrint-0.0.1/kePrint.js"></script>
<link href="Projeto01_files/lightable-0.0.1/lightable.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">TalkingData AdTracking - Desafio de detecção de fraude</h1>
<h4 class="author">Carlos Virgílio Beltrão Lessa</h4>
<h4 class="date">17 de janeiro de 2021</h4>

</div>


<div id="objetivo" class="section level1">
<h1><span class="header-section-number">1</span> Objetivo</h1>
<p>Detecção de Fraudes no Tráfego de Cliques em Propagandas de Aplicações Mobile As empresas de publicidade online lidam com uma grande quantidade de anúncios de clique, muitos são cliques fraudulentos. Este projeto envolve a investigação do comportamento do clique do usuário e da taxa de download. O objetivo é prever se um usuário fará o download do aplicativo mobile depois de clicar em seu anúncio. Isso será feito comparando a taxa de cliques dos usuários com os eventos de download do aplicativo. Analisando esses eventos fica claro que os downloads são muito raros quando comparados com os cliques, ou seja, os usuários clicam nos anúncios, mas não baixam o aplicativo posteriormente. Este trabalho destaca a importância da análise exploratória de dados, engenharia de atributos e o uso de algoritmos apropriados para lidar com dados desbalanceados.</p>
<p>O risco de fraude está em toda parte, mas para as empresas que anunciam online, a fraude de cliques pode acontecer em um volume avassalador, resultando em dados de cliques enganosos e dinheiro desperdiçado. Os canais de anúncios podem aumentar os custos simplesmente quando pessoas ou bots clicam nos anúncios em grande escala, o que na prática não gera o resultado esperado. Com mais de 1 bilhão de dispositivos móveis em uso todos os meses, a China é o maior mercado móvel do mundo e, portanto, sofre com grandes volumes de tráfego fraudulento.</p>
<p>A TalkingData (<a href="https://www.talkingdata.com" class="uri">https://www.talkingdata.com</a>), a maior plataforma de Big Data independente da China, cobre mais de 70% dos dispositivos móveis ativos em todo o país. Eles lidam com 3 bilhões de cliques por dia, dos quais 90% são potencialmente fraudulentos. Sua abordagem atual para impedir fraudes de cliques para desenvolvedores de aplicativos é medir a jornada do clique de um usuário em todo o portfólio e sinalizar endereços IP que produzem muitos cliques, mas nunca acabam instalando aplicativos. Com essas informações, eles criaram uma lista negra de IPs e uma lista negra de dispositivos.</p>
<p>Embora bem-sucedidos, eles querem estar sempre um passo à frente dos fraudadores e pediram a sua ajuda para desenvolver ainda mais a solução. Você está desafiado a criar um algoritmo que possa prever se um usuário fará o download de um aplicativo depois de clicar em um anúncio de aplicativo para dispositivos móveis.</p>
</div>
<div id="dados" class="section level1">
<h1><span class="header-section-number">2</span> Dados</h1>
<p>Os dados de treino fornecidos pela TalkingData foram coletados entre 06/11 e 09/11/2017 e consistem em 08 variáveis e 185 milhões de observações. Os dados de teste foram coletados no dia 10/11/2017 e consistem em 07 variáveis e 18 milhões de observações. Ambos os conjuntos de dados estão em formato CSV.</p>
</div>
<div id="pacotes-necessários" class="section level1">
<h1><span class="header-section-number">3</span> Pacotes necessários</h1>
<pre class="r"><code># Manipulação de dados
library(data.table)
library(dplyr)
library(purrr)
library(tibble)
library(janitor)

# Trabalhar com datas
library(lubridate)

# Balanceamento de dataset
library(ROSE)

# Seleção de variáveis
library(FSelector)
library(randomForest)

# Gráficos
library(ggplot2)
library(ggpubr)
library(ggalluvial)

# Tabelas
library(kableExtra)</code></pre>
</div>
<div id="carga-dos-dados" class="section level1">
<h1><span class="header-section-number">4</span> Carga dos dados</h1>
<p>Os datasets são grandes, então usaremos <strong>fread</strong> do pacote <strong>data.table</strong>.</p>
<p>A variável <strong>attributed_time</strong> não existe no dataset de teste, por isso não será carregada.</p>
<pre class="r"><code># Carrega o dataset de treino.
system.time(treino &lt;- fread(&quot;train.csv&quot;, na.strings=c(&quot;&quot;,&quot;NA&quot;),
                            drop = &quot;attributed_time&quot;, nThread = 16 ))</code></pre>
<pre><code>##    user  system elapsed 
##  28.649   2.505   9.381</code></pre>
<pre class="r"><code># Carrega os dados de teste
system.time(teste &lt;- fread(&quot;test.csv&quot;, na.strings=c(&quot;&quot;,&quot;NA&quot;),
                           nThread = 16 ))</code></pre>
<pre><code>##    user  system elapsed 
##   2.879   0.244   0.959</code></pre>
</div>
<div id="análise-exploratória" class="section level1">
<h1><span class="header-section-number">5</span> Análise exploratória</h1>
<div id="verificar-a-estrutura-e-resumo-estatístico-de-ambos-datsets" class="section level2">
<h2><span class="header-section-number">5.1</span> Verificar a estrutura e resumo estatístico de ambos datsets</h2>
<ul>
<li>Verificar dados missing.</li>
<li>Verificar a estrutura.</li>
<li>Verificar resumo estatístico.</li>
</ul>
<pre class="r"><code># Dados de treino
colSums(is.na(treino))</code></pre>
<pre><code>##            ip           app        device            os       channel 
##             0             0             0             0             0 
##    click_time is_attributed 
##             0             0</code></pre>
<pre class="r"><code>str(treino)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   184903890 obs. of  7 variables:
##  $ ip           : int  83230 17357 35810 45745 161007 18787 103022 114221 165970 74544 ...
##  $ app          : int  3 3 3 14 3 3 3 3 3 64 ...
##  $ device       : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ os           : int  13 19 13 13 13 16 23 19 13 22 ...
##  $ channel      : int  379 379 379 478 379 379 379 379 379 459 ...
##  $ click_time   : chr  &quot;2017-11-06 14:32:21&quot; &quot;2017-11-06 14:33:34&quot; &quot;2017-11-06 14:34:12&quot; &quot;2017-11-06 14:34:52&quot; ...
##  $ is_attributed: int  0 0 0 0 0 0 0 0 0 0 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<pre class="r"><code>summary(treino[treino$is_attributed==0])</code></pre>
<pre><code>##        ip              app             device             os        
##  Min.   :     1   Min.   :  0.00   Min.   :   0.0   Min.   :  0.00  
##  1st Qu.: 40216   1st Qu.:  3.00   1st Qu.:   1.0   1st Qu.: 13.00  
##  Median : 79353   Median : 12.00   Median :   1.0   Median : 18.00  
##  Mean   : 90690   Mean   : 11.97   Mean   :  21.7   Mean   : 22.67  
##  3rd Qu.:118146   3rd Qu.: 15.00   3rd Qu.:   1.0   3rd Qu.: 19.00  
##  Max.   :364778   Max.   :768.00   Max.   :4227.0   Max.   :956.00  
##     channel       click_time        is_attributed
##  Min.   :  0.0   Length:184447044   Min.   :0    
##  1st Qu.:145.0   Class :character   1st Qu.:0    
##  Median :258.0   Mode  :character   Median :0    
##  Mean   :268.7                      Mean   :0    
##  3rd Qu.:379.0                      3rd Qu.:0    
##  Max.   :500.0                      Max.   :0</code></pre>
<pre class="r"><code>summary(treino[treino$is_attributed==1])</code></pre>
<pre><code>##        ip              app             device              os        
##  Min.   :     1   Min.   :  0.00   Min.   :   0.00   Min.   :  0.00  
##  1st Qu.: 74987   1st Qu.: 12.00   1st Qu.:   1.00   1st Qu.: 13.00  
##  Median :157120   Median : 19.00   Median :   1.00   Median : 19.00  
##  Mean   :166084   Mean   : 29.78   Mean   :  31.81   Mean   : 24.49  
##  3rd Qu.:255006   3rd Qu.: 35.00   3rd Qu.:   1.00   3rd Qu.: 24.00  
##  Max.   :364778   Max.   :768.00   Max.   :4223.00   Max.   :866.00  
##     channel       click_time        is_attributed
##  Min.   :  0.0   Length:456846      Min.   :1    
##  1st Qu.:113.0   Class :character   1st Qu.:1    
##  Median :213.0   Mode  :character   Median :1    
##  Mean   :205.7                      Mean   :1    
##  3rd Qu.:274.0                      3rd Qu.:1    
##  Max.   :498.0                      Max.   :1</code></pre>
<p>Três variáveis apresentam médias com diferenças acentuadas quando confrontados os cliques legítimos (<strong>is_attributed</strong>==1) e fraudulentos (<strong>is_attributed</strong>==0). Média <strong>app</strong>: cliques legítimos 2,49X fraudulentos. Média <strong>ip</strong>: cliques legítimos 1,83X fraudulentos. Média <strong>device</strong>: cliques legítimos 1,45X fraudulentos.</p>
<pre class="r"><code># Dados de teste
colSums(is.na(teste))</code></pre>
<pre><code>##   click_id         ip        app     device         os    channel click_time 
##          0          0          0          0          0          0          0</code></pre>
<pre class="r"><code>str(teste)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   18790469 obs. of  7 variables:
##  $ click_id  : int  0 1 2 3 4 5 6 7 9 8 ...
##  $ ip        : int  5744 119901 72287 78477 123080 110769 12540 88637 14932 123701 ...
##  $ app       : int  9 9 21 15 12 18 3 27 18 12 ...
##  $ device    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ os        : int  3 3 19 13 13 13 1 19 10 53 ...
##  $ channel   : int  107 466 128 111 328 107 137 153 107 424 ...
##  $ click_time: chr  &quot;2017-11-10 04:00:00&quot; &quot;2017-11-10 04:00:00&quot; &quot;2017-11-10 04:00:00&quot; &quot;2017-11-10 04:00:00&quot; ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<pre class="r"><code>summary(teste)</code></pre>
<pre><code>##     click_id              ip              app             device       
##  Min.   :       0   Min.   :     0   Min.   :  0.00   Min.   :   0.00  
##  1st Qu.: 4697617   1st Qu.: 31558   1st Qu.:  3.00   1st Qu.:   1.00  
##  Median : 9395234   Median : 63936   Median : 12.00   Median :   1.00  
##  Mean   : 9395234   Mean   : 63069   Mean   : 12.21   Mean   :   1.73  
##  3rd Qu.:14092851   3rd Qu.: 95316   3rd Qu.: 18.00   3rd Qu.:   1.00  
##  Max.   :18790468   Max.   :126413   Max.   :521.00   Max.   :3031.00  
##        os            channel       click_time       
##  Min.   :  0.00   Min.   :  0.0   Length:18790469   
##  1st Qu.: 13.00   1st Qu.:135.0   Class :character  
##  Median : 18.00   Median :236.0   Mode  :character  
##  Mean   : 18.73   Mean   :264.8                     
##  3rd Qu.: 19.00   3rd Qu.:401.0                     
##  Max.   :604.00   Max.   :498.0</code></pre>
</div>
<div id="dicionário-de-dados" class="section level2">
<h2><span class="header-section-number">5.2</span> Dicionário de dados</h2>
<table>
<thead>
<tr class="header">
<th align="left">Variável</th>
<th align="left">Descrição</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>ip</strong></td>
<td align="left">Endereço IP do clique.</td>
</tr>
<tr class="even">
<td align="left"><strong>app</strong></td>
<td align="left">ID do aplicativo para marketing.</td>
</tr>
<tr class="odd">
<td align="left"><strong>device</strong></td>
<td align="left">ID do tipo de dispositivo do telefone celular do usuário.</td>
</tr>
<tr class="even">
<td align="left"><strong>os</strong></td>
<td align="left">ID da versão do sistema operacional do telefone celular do usuário.</td>
</tr>
<tr class="odd">
<td align="left"><strong>channel</strong></td>
<td align="left">ID do canal do editor de anúncios para celular.</td>
</tr>
<tr class="even">
<td align="left"><strong>click_time</strong></td>
<td align="left">Data/hora do clique</td>
</tr>
<tr class="odd">
<td align="left"><strong>attributed_time</strong></td>
<td align="left">Data/hora se o usuário baixar o aplicativo depois de clicar em um anúncio.</td>
</tr>
<tr class="even">
<td align="left"><strong>is_attributed</strong></td>
<td align="left">Variável a ser prevista, indicando que o aplicativo foi baixado.</td>
</tr>
</tbody>
</table>
</div>
<div id="diferenças-no-dicionário-de-dados-de-teste" class="section level2">
<h2><span class="header-section-number">5.3</span> Diferenças no dicionário de dados de teste</h2>
<table>
<thead>
<tr class="header">
<th align="left">Variável</th>
<th align="left">Descrição</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><strong>click_id</strong></td>
<td align="left">Variável adicional para identificar a previsão.</td>
</tr>
<tr class="even">
<td align="left"><strong>attributed_time</strong></td>
<td align="left">Não existe.</td>
</tr>
<tr class="odd">
<td align="left"><strong>is_attributed</strong></td>
<td align="left">Não existe - variável alvo.</td>
</tr>
</tbody>
</table>
<pre class="r"><code># Guarda click_id em um objeto e remove a variável.
click_id &lt;- teste$click_id
teste$click_id &lt;- NULL</code></pre>
</div>
<div id="diagrama-aluvial" class="section level2">
<h2><span class="header-section-number">5.4</span> Diagrama aluvial</h2>
<p>Esse tipo de gráfico é útil para descobrir interações entre diversas variáveis. O tamanho vertical de cada bloco é proporcional à frequência da variável. O próximo gráfico mostra altos fluxos de <strong>device</strong> 0 e 1 para os <strong>os</strong>, <strong>app</strong> e <strong>channel</strong> correspondentes quando <strong>is_attributed</strong> é igual a 1. Em particular, podemos ver que <strong>device</strong>== 1 não usa <strong>os</strong>==0 e <strong>device</strong>==0 não usa <strong>os</strong>==19, etc.</p>
<p>Gráfico extraído de: <a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<pre class="r"><code># Cria um dataset a partir de uma amostra de 3 milhões de observações
# Com o dataset completo (185 milhões) iria demorar muito a geração do gráfico
set.seed(0)
alluvia.ds &lt;-data.frame(treino[sample(.N, 3e6),][is_attributed == 1]
                [, freq := .N, keyby = .(device, os, app, channel)]
                [freq &gt; 15] %&gt;% unique())


# Plota o gráfico
ggplot(alluvia.ds,aes(weight = freq, axis1 = device, axis2 = os,
                          axis3 = app, axis4 = channel)) +
  geom_alluvium(aes(fill = is_attributed), width = 1/12) +
  geom_stratum(width = 1/12, fill = &quot;black&quot;, color = &quot;grey&quot;) +
  geom_label(stat = &quot;stratum&quot;, aes(label = after_stat(stratum))) +
  theme_bw() +
  scale_x_continuous(breaks = 1:4, labels = c(&quot;device&quot;, &quot;os&quot;, &quot;app&quot;, &quot;channel&quot;)) </code></pre>
<p><img src="Projeto01_files/figure-html/alluvial-1.png" width="672" /></p>
</div>
<div id="distribuição-de-classes" class="section level2">
<h2><span class="header-section-number">5.5</span> Distribuição de classes</h2>
<pre class="r"><code># Transformar a variável alvo em categórica
system.time(treino$is_attributed  &lt;- as.factor(treino$is_attributed))</code></pre>
<pre><code>##    user  system elapsed 
##   3.266   1.996   5.313</code></pre>
<pre class="r"><code># Verificar a distribuição.
kable(tabyl(treino$is_attributed) %&gt;% adorn_pct_formatting()) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
treino$is_attributed
</th>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
percent
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
184447044
</td>
<td style="text-align:left;">
99.8%
</td>
</tr>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
456846
</td>
<td style="text-align:left;">
0.2%
</td>
</tr>
</tbody>
</table>
<p>O conjunto de dados está extremamente desbalanceado. Temos 99.8% de registros para cliques fraudulentos e 0.2% para cliques legítimos.</p>
</div>
<div id="balancear-os-dados-com-undersampling" class="section level2">
<h2><span class="header-section-number">5.6</span> Balancear os dados com undersampling</h2>
<pre class="r"><code>system.time(treino &lt;- ovun.sample(is_attributed ~ ., data = treino,
                          method = &quot;under&quot;, p = 0.5, seed = 1 )$data)</code></pre>
<pre><code>##    user  system elapsed 
## 168.199  16.922 186.885</code></pre>
<pre class="r"><code>kable(tabyl(treino$is_attributed) %&gt;% adorn_pct_formatting()) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
treino$is_attributed
</th>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
percent
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
0
</td>
<td style="text-align:right;">
457243
</td>
<td style="text-align:left;">
50.0%
</td>
</tr>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
456846
</td>
<td style="text-align:left;">
50.0%
</td>
</tr>
</tbody>
</table>
<p>Dados balanceados. Os 185 milhões de observações foram reduzidos para 914 mil</p>
</div>
<div id="verificar-a-distribuição-dos-valores-de-app-device-os-e-channel-em-função-da-variável-alvo" class="section level2">
<h2><span class="header-section-number">5.7</span> Verificar a distribuição dos valores de <strong>app</strong>, <strong>device</strong>, <strong>os</strong> e <strong>channel</strong> em função da variável alvo</h2>
<pre class="r"><code>ggplot(treino, aes(x = ip, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/densidade_1-1.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = app, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/densidade_1-2.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = device, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/densidade_1-3.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = os, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/densidade_1-4.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = channel, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/densidade_1-5.png" width="672" /></p>
<p>Apenas a variável <strong>device</strong> não demonstrou densidade diferenciada entre cliques legítimos e fraudulentos.</p>
</div>
</div>
<div id="engenharia-de-atributos" class="section level1">
<h1><span class="header-section-number">6</span> Engenharia de atributos</h1>
<div id="obter-data-e-hora-a-partir-da-variável-attribute_time" class="section level2">
<h2><span class="header-section-number">6.1</span> Obter data e hora a partir da variável <strong>attribute_time</strong></h2>
<p>Primeiro nos dados de treino.</p>
<pre class="r"><code>treino$day &lt;-  day(ymd_hms(treino$click_time))
treino$hour &lt;- hour(ymd_hms(treino$click_time))
treino$minute &lt;- minute(ymd_hms(treino$click_time))
treino$second &lt;- second( ymd_hms(treino$click_time))

# Verificar a relevância de cada variável nova em relação a variável alvo

ggplot(treino, aes(x = day, fill = is_attributed)) +
  geom_density(alpha = 0.5)  + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_treino-1.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = hour, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_treino-2.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = minute, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_treino-3.png" width="672" /></p>
<pre class="r"><code>ggplot(treino, aes(x = second, fill = is_attributed)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_treino-4.png" width="672" /></p>
<p>Apenas em relação à hora há uma diferença significativa na densidade, os cliques legítimos são mais variados, enquanto os cliques fraudulentos são mais uniformes.</p>
<p>Em seguida nos dados de teste.</p>
<pre class="r"><code>teste$day &lt;-  day(ymd_hms(teste$click_time))
teste$hour &lt;- hour(ymd_hms(teste$click_time))
teste$minute &lt;- minute(ymd_hms(teste$click_time))
teste$second &lt;- second( ymd_hms(teste$click_time))

ggplot(teste, aes(x = hour, fill = day)) +
  geom_density(alpha = 0.5)  + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_teste-1.png" width="672" /></p>
<pre class="r"><code>ggplot(teste, aes(x = minute, fill = day)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_teste-2.png" width="672" /></p>
<pre class="r"><code>ggplot(teste, aes(x = second, fill = day)) +
  geom_density(alpha = 0.5) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/click_time_teste-3.png" width="672" /></p>
<pre class="r"><code>kable(tabyl(teste$hour) %&gt;% adorn_pct_formatting()) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:right;">
teste$hour
</th>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
percent
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
4
</td>
<td style="text-align:right;">
3344125
</td>
<td style="text-align:left;">
17.8%
</td>
</tr>
<tr>
<td style="text-align:right;">
5
</td>
<td style="text-align:right;">
2858427
</td>
<td style="text-align:left;">
15.2%
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:right;">
381
</td>
<td style="text-align:left;">
0.0%
</td>
</tr>
<tr>
<td style="text-align:right;">
9
</td>
<td style="text-align:right;">
2984808
</td>
<td style="text-align:left;">
15.9%
</td>
</tr>
<tr>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
3127993
</td>
<td style="text-align:left;">
16.6%
</td>
</tr>
<tr>
<td style="text-align:right;">
11
</td>
<td style="text-align:right;">
413
</td>
<td style="text-align:left;">
0.0%
</td>
</tr>
<tr>
<td style="text-align:right;">
13
</td>
<td style="text-align:right;">
3212566
</td>
<td style="text-align:left;">
17.1%
</td>
</tr>
<tr>
<td style="text-align:right;">
14
</td>
<td style="text-align:right;">
3261257
</td>
<td style="text-align:left;">
17.4%
</td>
</tr>
<tr>
<td style="text-align:right;">
15
</td>
<td style="text-align:right;">
499
</td>
<td style="text-align:left;">
0.0%
</td>
</tr>
</tbody>
</table>
</div>
<div id="obter-frequência-de-acessos-por-hora" class="section level2">
<h2><span class="header-section-number">6.2</span> Obter frequência de acessos por hora</h2>
<p>Nos dados de teste há um padrão de frequência de horas bem definido. As horas 4,5,9,10,13 e 14 tem suas frequências em torno de 15 a 18%. As horas 6,11 e 15 tem frequências próximas a zero. Os demais horários não existem na base de teste, pois o intervalo dos dados de teste é das 04:00:00 do dia 10/11/2017 às 15:00:00 do mesmo dia.</p>
<p>Criar variável para agrupar as frequências em três valores.</p>
<pre class="r"><code>frequentes &lt;- c(4,5,9,10,13,14)
nao_frequentes &lt;- c(6,11,15)
treino$freq_hour &lt;- ifelse(treino$hour %in% frequentes,1,
                    ifelse(treino$hour %in% nao_frequentes,2,3))

teste$freq_hour &lt;- ifelse(teste$hour %in% frequentes,1,
                           ifelse(teste$hour %in% nao_frequentes,2,3))</code></pre>
<p>As variáveis de minuto e segundo não mostram relevância, serão removidas.<br />
A variável <strong>click_time</strong> não é mais necessária, será removida.</p>
<pre class="r"><code>treino$minute &lt;- NULL
treino$second &lt;- NULL
teste$minute &lt;- NULL
teste$second &lt;- NULL

treino$click_time &lt;- NULL
teste$click_time &lt;- NULL</code></pre>
</div>
<div id="grupos-de-acesso-por-ip-dia-hora-aplicativo-e-so" class="section level2">
<h2><span class="header-section-number">6.3</span> Grupos de acesso por IP, dia, hora, aplicativo e SO</h2>
<p>Criar variáveis derivadas de contagens de agrupamentos de outras variáveis. O objetivo é identificar, por exemplo, se um aplicativo sendo executado em certo SO, oriundo de um determinado IP em determinados dia e hora baixou o aplicativo ou apenas clicou no anúncio.</p>
<p>Alguns trechos de código inspirados de: <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<pre class="r"><code># Dados de treino
setDT(treino)[, ip_day_freq_hour := .N, by = .(ip, day, freq_hour)]
setDT(treino)[, ip_day_hour := .N, by = .(ip, day, hour)]
setDT(treino)[, ip_day_hour_os := .N, by = .(ip, day, hour, os)]
setDT(treino)[, ip_day_hour_app := .N, by = .(ip, day, hour, app)]
setDT(treino)[, ip_day_hour_app_os := .N, by = .(ip, day, hour, app, os)]
setDT(treino)[, app_day_hour := .N, by = .(app, day, hour)]

# Dados de teste
setDT(teste)[, ip_day_freq_hour := .N, by = .(ip, day, freq_hour)]
setDT(teste)[, ip_day_hour := .N, by = .(ip, day, hour)]
setDT(teste)[, ip_day_hour_os := .N, by = .(ip, day, hour, os)]
setDT(teste)[, ip_day_hour_app := .N, by = .(ip, day, hour, app)]
setDT(teste)[, ip_day_hour_app_os := .N, by = .(ip, day, hour, app, os)]
setDT(teste)[, app_day_hour := .N, by = .(app, day, hour)]</code></pre>
<p>As variáveis <strong>ip</strong> e <strong>freq_hour</strong> não são mais necessárias, serão removidas.</p>
<pre class="r"><code>treino$ip &lt;- NULL
treino$freq_hour &lt;- NULL
teste$ip &lt;- NULL
teste$freq_hour &lt;- NULL

# Verificar a estrutura dos datasets
str(treino)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   914089 obs. of  13 variables:
##  $ app               : int  13 12 12 18 10 9 3 26 18 3 ...
##  $ device            : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ os                : int  15 26 13 22 8 19 30 32 22 13 ...
##  $ channel           : int  477 205 481 439 113 134 173 477 121 480 ...
##  $ is_attributed     : Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ day               : int  8 7 6 9 7 8 9 9 8 7 ...
##  $ hour              : int  2 9 23 11 0 0 8 6 12 23 ...
##  $ ip_day_freq_hour  : int  6 7 1 2 1 3 3 17 12 7 ...
##  $ ip_day_hour       : int  2 3 1 2 1 2 1 7 1 1 ...
##  $ ip_day_hour_os    : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ ip_day_hour_app   : int  1 2 1 2 1 1 1 1 1 1 ...
##  $ ip_day_hour_app_os: int  1 1 1 1 1 1 1 1 1 1 ...
##  $ app_day_hour      : int  213 1115 689 1028 238 1178 1040 199 941 876 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<pre class="r"><code>str(teste)</code></pre>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   18790469 obs. of  12 variables:
##  $ app               : int  9 9 21 15 12 18 3 27 18 12 ...
##  $ device            : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ os                : int  3 3 19 13 13 13 1 19 10 53 ...
##  $ channel           : int  107 466 128 111 328 107 137 153 107 424 ...
##  $ day               : int  10 10 10 10 10 10 10 10 10 10 ...
##  $ hour              : int  4 4 4 4 4 4 4 4 4 4 ...
##  $ ip_day_freq_hour  : int  91 2083 2135 1201 208 399 412 558 607 2718 ...
##  $ ip_day_hour       : int  34 403 229 239 60 120 90 93 106 539 ...
##  $ ip_day_hour_os    : int  3 17 69 98 27 20 6 23 1 1 ...
##  $ ip_day_hour_app   : int  8 50 13 10 7 16 16 1 13 52 ...
##  $ ip_day_hour_app_os: int  1 3 7 9 3 2 1 1 1 1 ...
##  $ app_day_hour      : int  475418 475418 77207 209436 396028 331896 444372 30530 331896 396028 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>Foram removidas as variáveis originais <strong>click_time</strong> e <strong>ip</strong>, as variáveis auxiliares <strong>minute</strong>, <strong>second</strong> e <strong>freq_hour</strong> em ambos datasets.<br />
Foram acrescentadas nos dois datasets as variáveis <strong>hour</strong>, <strong>ip_day_freq_hour</strong>, <strong>ip_day_hour</strong>, <strong>ip_day_hour_os</strong>, <strong>ip_day_hour_app</strong>, <strong>ip_day_hour_app_os</strong> e <strong>app_day_hour</strong></p>
</div>
</div>
<div id="seleção-de-variáveis" class="section level1">
<h1><span class="header-section-number">7</span> Seleção de variáveis</h1>
<p>Utilizaremos dois métodos para obter lista com as variáveis mais significativas: Random Forest e Chi Quadrado.</p>
<div id="seleção-de-variáveis-random-forest" class="section level2">
<h2><span class="header-section-number">7.1</span> Seleção de variáveis – Random Forest</h2>
<pre class="r"><code># Criando um modelo para identificar com randomForest
modelo &lt;- randomForest(is_attributed ~ . , 
                       data = treino[sample(.N, 100000), ], 
                       ntree = 100, 
                       nodesize = 10,
                       importance = TRUE)

# Plotando as variáveis por grau de importância
varImpPlot(modelo)</code></pre>
<p><img src="Projeto01_files/figure-html/seleciona_rf-1.png" width="672" /></p>
<pre class="r"><code># Listando as seis variáveis mais importantes segundo acurácia
kable(modelo$importance %&gt;% as.data.frame() %&gt;%
  select(MeanDecreaseAccuracy) %&gt;% 
  arrange(desc(MeanDecreaseAccuracy)) %&gt;%
  head(n = 6)) %&gt;% 
  kable_styling(full_width = F,
             bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
MeanDecreaseAccuracy
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
app
</td>
<td style="text-align:right;">
0.2749008
</td>
</tr>
<tr>
<td style="text-align:left;">
channel
</td>
<td style="text-align:right;">
0.0954770
</td>
</tr>
<tr>
<td style="text-align:left;">
app_day_hour
</td>
<td style="text-align:right;">
0.0690890
</td>
</tr>
<tr>
<td style="text-align:left;">
device
</td>
<td style="text-align:right;">
0.0406571
</td>
</tr>
<tr>
<td style="text-align:left;">
ip_day_freq_hour
</td>
<td style="text-align:right;">
0.0237369
</td>
</tr>
<tr>
<td style="text-align:left;">
os
</td>
<td style="text-align:right;">
0.0206568
</td>
</tr>
</tbody>
</table>
<pre class="r"><code># Listando as seis variáveis mais importantes segundo gini
kable(modelo$importance %&gt;% as.data.frame() %&gt;%
  select(MeanDecreaseGini) %&gt;% 
  arrange(desc(MeanDecreaseGini)) %&gt;%
  head(n = 6)) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
MeanDecreaseGini
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
app
</td>
<td style="text-align:right;">
16675.881
</td>
</tr>
<tr>
<td style="text-align:left;">
channel
</td>
<td style="text-align:right;">
7572.768
</td>
</tr>
<tr>
<td style="text-align:left;">
app_day_hour
</td>
<td style="text-align:right;">
4839.547
</td>
</tr>
<tr>
<td style="text-align:left;">
ip_day_freq_hour
</td>
<td style="text-align:right;">
3788.245
</td>
</tr>
<tr>
<td style="text-align:left;">
device
</td>
<td style="text-align:right;">
2633.464
</td>
</tr>
<tr>
<td style="text-align:left;">
os
</td>
<td style="text-align:right;">
2356.045
</td>
</tr>
</tbody>
</table>
</div>
<div id="seleção-de-variáveis-chi-quadrado" class="section level2">
<h2><span class="header-section-number">7.2</span> Seleção de variáveis – Chi Quadrado</h2>
<pre class="r"><code># Método do chi.squared
variaveis &lt;- chi.squared(is_attributed ~ ., treino[sample(.N, 100000), ])


# Listando as seis variáveis mais importantes segundo chi.squared
kable(variaveis %&gt;% arrange(desc(attr_importance))  %&gt;% head(n = 6)) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
</th>
<th style="text-align:right;">
attr_importance
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
app
</td>
<td style="text-align:right;">
0.8356441
</td>
</tr>
<tr>
<td style="text-align:left;">
channel
</td>
<td style="text-align:right;">
0.8218446
</td>
</tr>
<tr>
<td style="text-align:left;">
app_day_hour
</td>
<td style="text-align:right;">
0.7072795
</td>
</tr>
<tr>
<td style="text-align:left;">
os
</td>
<td style="text-align:right;">
0.4835680
</td>
</tr>
<tr>
<td style="text-align:left;">
device
</td>
<td style="text-align:right;">
0.4386092
</td>
</tr>
<tr>
<td style="text-align:left;">
ip_day_freq_hour
</td>
<td style="text-align:right;">
0.3493957
</td>
</tr>
</tbody>
</table>
<p>Independentemente do método há coincidência das variáveis mais relevantes.</p>
</div>
<div id="reorganização-dos-conjuntos-de-dados" class="section level2">
<h2><span class="header-section-number">7.3</span> Reorganização dos conjuntos de dados</h2>
<p>Criar um vetor de caracteres contendo as seis variáveis significativas.</p>
<pre class="r"><code>variaveis_imp &lt;- cutoff.k(variaveis %&gt;% arrange(desc(attr_importance)), 6)

# Acrescentar a variável alvo
reord_var &lt;- c(&quot;is_attributed&quot;,variaveis_imp)

# Dataset de treino com a variável alvo e as variáveis preditoras relevantes
treino &lt;- treino[,..reord_var]

# Dataset de teste com as preditoras relevantes
teste &lt;- teste[,..variaveis_imp]</code></pre>
</div>
</div>
<div id="modelos" class="section level1">
<h1><span class="header-section-number">8</span> Modelos</h1>
<p>Utilizaremos quatro modelos ML da plataforma H2O.ai.</p>
<div id="sobre-a-h2o.ai" class="section level2">
<h2><span class="header-section-number">8.1</span> Sobre a H2O.ai</h2>
<blockquote>
<p>A H2O.ai é uma empresa de software visionária com sede no Vale do Silício, que tem como missão democratizar a utilização de inteligência artificial. Com um time repleto de makers, especialistas em data science e Kaggle grandmasters, a H2O.ai se tornou a líder em criar produtos e tecnologias abertas para ciência de dados e aprendizado de máquina (machine learning). <a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a></p>
</blockquote>
</div>
<div id="iniciar-o-cluster-e-preparar-os-datasets" class="section level2">
<h2><span class="header-section-number">8.2</span> Iniciar o cluster e preparar os datasets</h2>
<pre class="r"><code># Kit de modelos H2O 
library(h2o)

levels(treino$is_attributed) = make.names(unique(treino$is_attributed))

# Inicia o cluster H2O
h2o.init(nthreads=-1, max_mem_size=&quot;40G&quot;)</code></pre>
<pre><code>##  Connection successful!
## 
## R is connected to the H2O cluster: 
##     H2O cluster uptime:         8 hours 15 minutes 
##     H2O cluster timezone:       America/Maceio 
##     H2O data parsing timezone:  UTC 
##     H2O cluster version:        3.32.0.1 
##     H2O cluster version age:    3 months and 9 days !!! 
##     H2O cluster name:           H2O_started_from_R_carloslessa_ehs110 
##     H2O cluster total nodes:    1 
##     H2O cluster total memory:   38.31 GB 
##     H2O cluster total cores:    4 
##     H2O cluster allowed cores:  4 
##     H2O cluster healthy:        TRUE 
##     H2O Connection ip:          localhost 
##     H2O Connection port:        54321 
##     H2O Connection proxy:       NA 
##     H2O Internal Security:      FALSE 
##     H2O API Extensions:         Amazon S3, XGBoost, Algos, AutoML, Core V3, TargetEncoder, Core V4 
##     R Version:                  R version 3.6.3 (2020-02-29)</code></pre>
<pre class="r"><code># Limpa o ambiente - apenas no caso do cluster já estar em execução
h2o.removeAll()

# Não exibir a barra de progresso na saída RMarkdown
h2o.no_progress()

# Converte em dataframe H2O
system.time(h2o_treino &lt;- as.h2o(treino))</code></pre>
<pre><code>##    user  system elapsed 
##   2.153   0.024   2.774</code></pre>
<pre class="r"><code>system.time(h2o_teste &lt;- as.h2o(teste))</code></pre>
<pre><code>##    user  system elapsed 
##  31.695   0.401  34.577</code></pre>
<pre class="r"><code># Remove datasets para liberar memória
rm(teste)
rm(treino)

# Identifica a variável alvo e as preditoras
response &lt;- &quot;is_attributed&quot;
predictors &lt;- setdiff(names(h2o_treino), response)</code></pre>
</div>
<div id="random-forest" class="section level2">
<h2><span class="header-section-number">8.3</span> Random Forest</h2>
<p>Distributed Random Forest (DRF) é uma ferramenta poderosa de classificação e regressão. Quando fornecido um conjunto de dados, o DRF gera uma floresta de árvores, em vez de uma única árvore de classificação ou regressão.<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a></p>
<pre class="r"><code># Modelo Random Forest
system.time(model_rf &lt;-
              h2o.randomForest(x = predictors,
                               y = response,
                               training_frame = h2o_treino,
                               nfolds = 5,
                               fold_assignment = &quot;Modulo&quot;,
                               ntrees = 50,
                               max_depth = 8,
                               min_rows = 1,
                               sample_rate = 0.7,
                               keep_cross_validation_predictions = T,
                               seed = 1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.481   0.025  79.840</code></pre>
<pre class="r"><code># Previsões com Random Forest
system.time(predic_rf &lt;- h2o.predict(model_rf, h2o_teste))</code></pre>
<pre><code>##    user  system elapsed 
##   0.158   0.010  37.624</code></pre>
<pre class="r"><code># Converter de H2O format em data frame
system.time(predic_rf.df &lt;- as.data.frame(predic_rf))</code></pre>
<pre><code>##    user  system elapsed 
##  24.568   0.370  41.486</code></pre>
<pre class="r"><code># Salvar em formato csv para submissão no Kaggle 
result_rf &lt;- data.frame(click_id = click_id,
                        is_attributed = ifelse(predic_rf.df$X1 &gt; 0.5, 1 ,0))

fwrite(result_rf,&#39;talkingdata_kaggle_rf.csv&#39;)</code></pre>
</div>
<div id="gradient-boosted" class="section level2">
<h2><span class="header-section-number">8.4</span> Gradient Boosted</h2>
<p>Gradient Boosting Machine é um método de conjunto de aprendizagem progressiva. A heurística orientadora é que bons resultados preditivos podem ser obtidos por meio de aproximações cada vez mais refinadas.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a></p>
<pre class="r"><code># Modelo Gradient Boosted
system.time(model_gbm &lt;-
              h2o.gbm(x = predictors,
                      y = response,
                      training_frame = h2o_treino,
                      distribution = &quot;bernoulli&quot;,
                      ntrees = 50,
                      max_depth = 8,
                      min_rows = 1,
                      learn_rate = 0.1,
                      sample_rate = 0.7,
                      col_sample_rate = 0.9,
                      nfolds = 5,
                      fold_assignment = &quot;Modulo&quot;,
                      keep_cross_validation_predictions = T,
                      seed = 1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.486   0.028  85.041</code></pre>
<pre class="r"><code># Previsões com Gradient Boosted
system.time(predic_gbm &lt;- h2o.predict(model_gbm, h2o_teste))</code></pre>
<pre><code>##    user  system elapsed 
##   0.172   0.010  38.588</code></pre>
<pre class="r"><code># Converter de H2O format em data frame
system.time(predic_gbm.df &lt;- as.data.frame(predic_gbm))</code></pre>
<pre><code>##    user  system elapsed 
##  25.841   0.399  43.294</code></pre>
<pre class="r"><code># Salvar em formato csv para submissão no Kaggle 
result_gbm &lt;- data.frame(click_id = click_id,
                          is_attributed = ifelse(predic_gbm.df$X1 &gt; 0.5, 1, 0))

fwrite(result_gbm,&#39;talkingdata_kaggle_gbm.csv&#39;)</code></pre>
</div>
<div id="extreme-gradient-boosted" class="section level2">
<h2><span class="header-section-number">8.5</span> eXtreme Gradient Boosted</h2>
<p>XGBoost constrói muitos modelos sequencialmente, com cada novo modelo tentando corrigir as deficiências do modelo anterior. Cada novo modelo adicionado ao conjunto é uma árvore de decisão. O XGBoost fornece boosting de árvore paralela.<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<pre class="r"><code># Modelo eXtreme Gradient Boosting
system.time(model_xgb &lt;-
              h2o.xgboost(x = predictors,
                          y = response,
                          training_frame = h2o_treino,
                          distribution = &quot;bernoulli&quot;,
                          ntrees = 50,
                          max_depth = 8,
                          min_rows = 1,
                          learn_rate = 0.1,
                          sample_rate = 0.7,
                          col_sample_rate = 0.9,
                          nfolds = 5,
                          fold_assignment = &quot;Modulo&quot;,
                          keep_cross_validation_predictions = T,
                          seed = 1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.378   0.025  62.610</code></pre>
<pre class="r"><code># Previsões com eXtreme Gradient Boosting
system.time(predic_xgb &lt;- h2o.predict(model_xgb, h2o_teste))</code></pre>
<pre><code>##    user  system elapsed 
##   0.087   0.011  16.370</code></pre>
<pre class="r"><code># Converter de H2O format em data frame
system.time(predic_xgb.df &lt;- as.data.frame(predic_xgb))</code></pre>
<pre><code>##    user  system elapsed 
##  18.160   0.268  36.905</code></pre>
<pre class="r"><code># Salvar em formato csv para submissão no Kaggle 
result_xgb &lt;- data.frame(click_id = click_id,
                          is_attributed = ifelse(predic_xgb.df$X1 &gt; 0.5, 1, 0))

fwrite(result_xgb,&quot;talkingdata_kaggle_xgb.csv&quot;)</code></pre>
</div>
<div id="stacked-ensemble-super-learner" class="section level2">
<h2><span class="header-section-number">8.6</span> Stacked Ensemble (Super Learner)</h2>
<p>Algoritmo que agrupa modelos para encontrar a combinação ideal. Recebe como parâmetro uma lista com dois ou mais modelos.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<pre class="r"><code># Modelo Stacked Ensemble (Super Learner)
system.time(model_stck &lt;-
              h2o.stackedEnsemble(x = predictors,
                             y = response,
                             training_frame = h2o_treino,
                             metalearner_algorithm = &quot;AUTO&quot;,
                             metalearner_nfolds = 5,
                             base_models = list(model_rf@model_id,
                                                model_gbm@model_id,
                                                model_xgb@model_id),
                             metalearner_fold_assignment = &quot;AUTO&quot;,
                             seed = 1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.191   0.000   5.242</code></pre>
<pre class="r"><code># Previsões com Stacked Ensemble (Super Learner)
system.time(predic_stck &lt;- h2o.predict(model_stck, h2o_teste))</code></pre>
<pre><code>##    user  system elapsed 
##   0.362   0.021  87.396</code></pre>
<pre class="r"><code># Converter de H2O format em data frame
system.time(predic_stck.df &lt;- as.data.frame(predic_stck))</code></pre>
<pre><code>##    user  system elapsed 
##  28.266   0.365  45.332</code></pre>
<pre class="r"><code># Salvar em formato csv para submissão no Kaggle 
result_stck &lt;- data.frame(click_id = click_id,
                          is_attributed = ifelse(predic_stck.df$X1 &gt; 0.5, 1, 0))

fwrite(result_stck,&#39;talkingdata_kaggle_stck.csv&#39;)</code></pre>
</div>
</div>
<div id="avaliação-dos-modelos" class="section level1">
<h1><span class="header-section-number">9</span> Avaliação dos modelos</h1>
<pre class="r"><code># Objetos com os dados de performance
perf_rf &lt;- h2o.performance(model_rf)
perf_gbm &lt;- h2o.performance(model_gbm)
perf_xgb &lt;- h2o.performance(model_xgb)
perf_stck &lt;- h2o.performance(model_stck)</code></pre>
<div id="índice-gini" class="section level2">
<h2><span class="header-section-number">9.1</span> Índice GINI</h2>
<p>O índice de GINI quantifica a desigualdade entre os valores de uma distribuição de frequência e pode ser usado para medir a qualidade de um classificador binário. Um índice de GINI de 0 expressa igualdade perfeita (ou um classificador totalmente inútil), enquanto um índice de GINI de 1 expressa a desigualdade máxima (ou um classificador perfeito).</p>
<pre class="r"><code># Extrai GINI
GINI &lt;- c(h2o.giniCoef(perf_rf),h2o.giniCoef(perf_gbm),
          h2o.giniCoef(perf_xgb),h2o.giniCoef(perf_stck))</code></pre>
</div>
<div id="auc" class="section level2">
<h2><span class="header-section-number">9.2</span> AUC</h2>
<p>Área sob a curva ROC. Avalia quão bem um modelo de classificação binária é capaz de distinguir entre verdadeiros positivos e falsos positivos. Um AUC de 1 indica um classificador perfeito, enquanto um AUC de 0,5 indica um classificador pobre, cujo desempenho não é melhor do que adivinhação aleatória.</p>
<pre class="r"><code># Extrai AUC
AUC &lt;- c(h2o.auc(perf_rf),h2o.auc(perf_gbm),
         h2o.auc(perf_xgb),h2o.auc(perf_stck))</code></pre>
</div>
<div id="aucpr" class="section level2">
<h2><span class="header-section-number">9.3</span> AUCPR</h2>
<p>Área sob a curva de recall de precisão. Recall é a capacidade de um modelo detectar todos os exemplos positivos e a precisão é a capacidade de um modelo evitar rotular amostras negativas como positivas.</p>
<pre class="r"><code># Extrai AUCPR
AUCPR &lt;- c(h2o.aucpr(perf_rf), h2o.aucpr(perf_gbm),
         h2o.aucpr(perf_xgb), h2o.aucpr(perf_stck))</code></pre>
</div>
<div id="tabela-de-performance" class="section level2">
<h2><span class="header-section-number">9.4</span> Tabela de performance</h2>
<pre class="r"><code># Nome dos modelos
Modelo &lt;- c(&quot;Random Forest&quot;,&quot;Gradient Boosted&quot;,
             &quot;eXtreme Gradient Boosting&quot;,&quot;Stacked Ensemble&quot;)

# Tabela de performance
kable(data.frame(Modelo,GINI,AUC,AUCPR)) %&gt;% 
  kable_styling(full_width = F,
                bootstrap_options = c(&quot;striped&quot;,&quot;hover&quot;,&quot;condensed&quot;,&quot;responsive&quot;))</code></pre>
<table class="table table-striped table-hover table-condensed table-responsive" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Modelo
</th>
<th style="text-align:right;">
GINI
</th>
<th style="text-align:right;">
AUC
</th>
<th style="text-align:right;">
AUCPR
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Random Forest
</td>
<td style="text-align:right;">
0.9105616
</td>
<td style="text-align:right;">
0.9552808
</td>
<td style="text-align:right;">
0.9643519
</td>
</tr>
<tr>
<td style="text-align:left;">
Gradient Boosted
</td>
<td style="text-align:right;">
0.9362530
</td>
<td style="text-align:right;">
0.9681265
</td>
<td style="text-align:right;">
0.9748053
</td>
</tr>
<tr>
<td style="text-align:left;">
eXtreme Gradient Boosting
</td>
<td style="text-align:right;">
0.9371607
</td>
<td style="text-align:right;">
0.9685804
</td>
<td style="text-align:right;">
0.9751885
</td>
</tr>
<tr>
<td style="text-align:left;">
Stacked Ensemble
</td>
<td style="text-align:right;">
0.9319213
</td>
<td style="text-align:right;">
0.9659607
</td>
<td style="text-align:right;">
0.9740864
</td>
</tr>
</tbody>
</table>
</div>
<div id="gráfico-resumo-do-shap" class="section level2">
<h2><span class="header-section-number">9.5</span> Gráfico resumo do SHAP</h2>
<p>Baseado nos valores de Shapley.<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a></p>
<pre class="r"><code># Gráfico resumo do SHAP

h2o.shap_summary_plot(model_rf, h2o_teste) + 
  ggtitle(&#39;Random Forest&#39;) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/avalia_shap-1.png" width="672" /></p>
<pre class="r"><code>h2o.shap_summary_plot(model_gbm, h2o_teste) + 
  ggtitle(&#39;Gradient Boosted&#39;) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/avalia_shap-2.png" width="672" /></p>
<pre class="r"><code>h2o.shap_summary_plot(model_xgb, h2o_teste) + 
  ggtitle(&#39;eXtreme Gradient Boosting&#39;) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/avalia_shap-3.png" width="672" /></p>
</div>
<div id="curvas-roc-dos-quatro-modelos" class="section level2">
<h2><span class="header-section-number">9.6</span> Curvas ROC dos quatro modelos</h2>
<p>Código obtido de:<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a></p>
<pre class="r"><code># Plotando as curvas ROC dos quatro modelos
list(model_rf,model_gbm,model_xgb,model_stck) %&gt;% 
  # Mapeia a função para cada elemento da lista
  map(function(x) x %&gt;% h2o.performance() %&gt;% 
        # Para todos esses &#39;paths&#39; nos objetos
        .@metrics %&gt;% .$thresholds_and_metric_scores %&gt;% 
        # Extrai as taxas de verdadeiros e falsos positivos (tpr e fpr)
        .[c(&#39;tpr&#39;,&#39;fpr&#39;)] %&gt;% 
        # Adiciona (0,0) e (1,1) para os pontos de início e fim da curva ROC
        add_row(tpr=0,fpr=0,.before=T) %&gt;% 
        add_row(tpr=1,fpr=1,.before=F)) %&gt;% 
  # Adiciona coluna para os nomes dos modelos para em seguida agrupar no ggplot2
  map2(Modelo, function(x, y) x %&gt;% add_column(Modelo = y)) %&gt;% 
  # Agrupa os quatro datasets em um
  reduce(rbind) %&gt;% 
  # Plota fpr e tpr, mapeando as cores por modelos
  ggplot(aes(fpr, tpr, col = Modelo))+
  geom_line(size = 0.5 , linetype = &quot;dashed&quot;)+
  geom_segment(aes(x = 0,y = 0, xend = 1, yend = 1),
               linetype = &quot;dashed&quot;, col = &#39;darkgrey&#39;)+
  xlab(&#39;Taxa de Falsos Positivos&#39;)+
  ylab(&#39;Taxa de Verdaeiros Positivos&#39;)+
  ggtitle(&#39;Curva ROC&#39;) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/avalia_roc-1.png" width="672" /></p>
</div>
<div id="curvas-prroc-dos-quatro-modelos" class="section level2">
<h2><span class="header-section-number">9.7</span> Curvas PRROC dos quatro modelos</h2>
<pre class="r"><code># Plotando as curvas PRROC dos quatro modelos
list(model_rf,model_gbm,model_xgb,model_stck) %&gt;% 
  # Mapeia a função para cada elemento da lista
  map(function(x) x %&gt;% h2o.performance() %&gt;% 
        # Para todos esses &#39;paths&#39; nos objetos
        .@metrics %&gt;% .$thresholds_and_metric_scores %&gt;% 
        # Extrai as taxas de recall e precision
        .[c(&#39;recall&#39;,&#39;precision&#39;)] %&gt;% 
        # Adiciona (0,1) e (1,0) para os pontos de início e fim da curva PRROC
        add_row(recall=0,precision=1,.before=F) %&gt;% 
        add_row(recall=1,precision=0,.before=T)) %&gt;% 
  # Adiciona coluna para os nomes dos modelospara em seguida agrupar no ggplot2
  map2(Modelo, function(x, y) x %&gt;% add_column(Modelo = y)) %&gt;% 
  # Agrupa os quatro datasets em um
  reduce(rbind) %&gt;% 
  # Plota precision e recall, mapeando as cores por modelos
  ggplot(aes(recall, precision, col = Modelo))+
  geom_line(size = 0.5 , linetype = &quot;dashed&quot;)+
  geom_segment(aes(x = 0,y = 1, xend = 1, yend = 0),
               linetype = &quot;dashed&quot;, col = &#39;darkgrey&#39;)+
  xlab(&#39;Recall&#39;)+
  ylab(&#39;Precision&#39;)+
  ggtitle(&#39;Curva PRROC&#39;) + theme_bw()</code></pre>
<p><img src="Projeto01_files/figure-html/avalia_prroc-1.png" width="672" /></p>
</div>
</div>
<div id="resultado-da-submissão-ao-kaggle" class="section level1">
<h1><span class="header-section-number">10</span> Resultado da Submissão ao Kaggle</h1>
<p><img src="kaggle.png" /></p>
</div>
<div id="conclusão" class="section level1">
<h1><span class="header-section-number">11</span> Conclusão</h1>
<p>Neste trabalho vimos o quanto a análise exploratória de dados pode nos indicar os caminhos para a engenharia de atributos, aplicamos a técnica de undersampling para balancear as classes e utilizamos métodos distintos para selecionar variáveis relevantes . Aplicamos aos dados quatro algoritmos de machine learning, comparamos seus desempenhos e submetemos ao Kaggle os arquivos resultantes das predições.</p>
<p>Comparando os resultados com os dados de treino e da submissão ao Kaggle vimos diferenças significativas, indicando provável overfitting, ou seja, algumas iterações de todo o processo são necessárias para aproximar os resultados de teste aos de treino, porém está fora do escopo deste trabalho.</p>
</div>
<div id="material-de-apoio" class="section level1">
<h1><span class="header-section-number">12</span> Material de Apoio</h1>
<ul>
<li><a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/performance-and-prediction.html">Performance and Prediction</a></li>
<li><a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/explain.html">Model Explainability</a></li>
<li><a href="https://docs.microsoft.com/pt-br/azure/machine-learning/how-to-understand-automated-ml">Avaliar os resultados do experimento do Machine Learning automatizado</a></li>
</ul>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>TalkingData Exploratory Analysis and Class Imbalance<br />
<a href="https://www.kaggle.com/kailex/talkingdata-eda-and-class-imbalance" class="uri">https://www.kaggle.com/kailex/talkingdata-eda-and-class-imbalance</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>TalkingData - H2O need Something else<br />
<a href="https://www.kaggle.com/blastchar/talkingdata-h2o-need-something-else" class="uri">https://www.kaggle.com/blastchar/talkingdata-h2o-need-something-else</a><a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>H2O.ai Democratizando a Inteligência Artificial<br />
<a href="https://medium.com/h2o-ai-brasil/h2o-ai-democratizando-a-intelig%C3%AAncia-artificial-99d01862b1b1" class="uri">https://medium.com/h2o-ai-brasil/h2o-ai-democratizando-a-intelig%C3%AAncia-artificial-99d01862b1b1</a><a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Distributed Random Forest (DRF)<br />
<a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/drf.html" class="uri">https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/drf.html</a><a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Gradient Boosting Machine (GBM) <a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm.html" class="uri">http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm.html</a><a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>XGBoost<br />
<a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/xgboost.html" class="uri">https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/xgboost.html</a><a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>Stacked Ensembles<br />
<a href="https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/stacked-ensembles.html" class="uri">https://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/stacked-ensembles.html</a><a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>SHAP: O que é e por que usar<br />
<a href="https://medium.com/big-data-blog/shap-o-que-%C3%A9-e-por-que-usar-6b01d37ae592" class="uri">https://medium.com/big-data-blog/shap-o-que-%C3%A9-e-por-que-usar-6b01d37ae592</a><a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>How to directly plot ROC of h2o model object in R<br />
<a href="https://stackoverflow.com/questions/44034944/how-to-directly-plot-roc-of-h2o-model-object-in-r" class="uri">https://stackoverflow.com/questions/44034944/how-to-directly-plot-roc-of-h2o-model-object-in-r</a><a href="#fnref9" class="footnote-back">↩︎</a></p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
